<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript
<code>
    数据类型（8种）
    Undefined、Null、Boolean、String、Number、Symbol(ES6)、BigInt(ES6)	Object（包括数组、函数、对象等）

    Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题
    BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
</code>
<code>
    堆内存与栈内存
    在操作系统中，内存被分为栈区和堆区，栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。
    在数据结构中，栈中数据的存取方式为先进后出。堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。

    数据存储方式

    基本数据类型的数据直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储
    引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
</code>
<code>
    数据类型检测

    优缺点	typeof	instanceof	constructor	Object.prototype.toString.call
    优点	使用简单	能检测出引用类型数据	基本能检测所有的类型（除了null和undefined）	检测出所有的类型
    缺点	只能检测出除null外的基本数据类型和引用数据类型中的function	不能检测出基本类型，且不能跨iframe	constructor易被修改，也不能跨iframe	IE6下，undefined和null均为Object
</code>
<code>
    判断数组的方式
    Object.prototype.toString.call([1, 2, 3]) // [object Array]
    通过ES6的Array.isArray([1, 2, 3])做判断 // true or false
    [1, 2, 3] instanceof Array // true or false
    Array.prototype.isPrototypeOf([1, 2, 3]) // true or false
    通过原型链去判断：[1, 2, 3].__proto__ === Array.prototype
</code>
<code>
    Undefined与Null

    Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null
    undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化
    undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0
    typeof null 的返回值为object，且undefined == null返回true
</code>
<code>
    this的指向问题

    this是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象
    this 永远指向最后调用它的那个对象

    函数调用模式：当一个函数不是一个对象的属性，直接作为函数来调用时，this指向全局对象
    方法调用模式：当一个函数作为一个对象的方法来调用时，this指向这个对象
    构造器调用模式：如果一个函数使用new调用时，函数在执行前会创建一个新的对象，this就指向这个新的对象
    如何改变this的指向？
    使用ES6箭头函数，箭头函数不绑定this，箭头函数的this使用指向函数定义时的this
    在函数内部定义一个变量_this保存this
    使用 apply、call、bind
    new 实例化一个对象
    this绑定的优先级：new绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级
</code>
<code>
    apply、bind和call

    apply、bind和call都可以改变this的指向
    apply(thisArg[, argsArray])
    apply() 方法调用一个具有给定 this 值的函数，以及以一个数组（或一个类数组对象）的形式提供的参数
    thisArg: 在函数运行时使用的 this 值。请注意，this 可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装

    argsArray: 可选。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数

    返回值：调用有指定 this 值和参数的函数的结果

    const numbers = [1, 3, 2, 5, 7, 4]
    const max = Math.max.apply(null, numbers)   // 7
    const min = Math.max.apply(null, numbers)   // 1
    call(thisArg[, arg1[, arg2[, ...]]])
    call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数
    该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组
    thisArg: 在函数运行时使用的 this 值。请注意，this 可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装

    arg1, arg2, ...: 指定的参数列表

    返回值：调用有指定 this 值和参数的函数的结果

    bind(thisArg[, arg1[, arg2[, ...]]])
    bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用（bind 是创建一个新的函数，我们必须要手动去调用）
    thisArg: 调用绑定函数时作为 this 参数传递给目标函数的值。如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg

    arg1, arg2, ...: 指定的参数列表

    返回值：返回一个原函数的拷贝，并拥有指定的 this 值和初始参数
</code>
<code>
    伪数组（类数组）

    一个拥有length属性和若干索引属性的对象可以被成为类数组对象，类数组对象和数组类似，但不能调用数组的方法
    常见的类数组对象：arguments和DOM方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数

    类数组如何转换为数组

    通过call方法调用数组的slice方法
    Array.prototype.slice.call(arrayLike);
    通过call方法调用数组的splice方法
    Array.prototype.splice.call(arrayLike, 0);
    通过apply调用数组的concat方法
    Array.prototype.concat.apply([], arrayLike);
    通过Array.from方法
    Array.from(arrayLike);
    通过展开运算符
    const array = [...arrayLike]
</code>
<code>
    如何遍历类数组

    arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组
    使用call或apply方法
    function sum() {
    Array.prototype.forEach.call(arguements, a => { console.log(a) })
    }

    function sum() {
    Array.prototype.forEach.apply(arguements, [a => { console.log(a)] })
    }
    使用Array.from方法将类数组转化成数组
    function sum() {
    const args = Array.from(arguements)
    args.forEach(a => { console.log(a) })
    }
    使用展开运算符将类数组转成数组
    function sum() {
    const args = [...arguements]
    args.forEach(a => { console.log(a) })
    }
</code>
<code>
    for...in与for...of

    区别	for...in	for...of
    遍历对象	对象的键名，会遍历整个原型链，性能差	对象的键值，只遍历当前对象
    遍历数组	返回数组中所有可枚举属性，包括原型链上的属性	只返回对应数组的下标对应的属性值

    for...in循环主要是为了遍历对象，不适用于遍历数组，for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象
</code>
<code>
    ajax

    AJAX Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：
    本身是针对MVC编程，不符合前端MVVM的浪潮
    基于原生XHR开发，XHR本身的架构不清晰
    不符合关注分离（Separation of Concerns）的原则
    配置和调用方式非常混乱，而且基于事件的异步模型不友好
</code>
<code>
    fetch

    Fetch fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象
    优点	缺点
    语法简洁，更加语义化	fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
    基于标准 Promise 实现，支持 async/await	fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
    更加底层，提供的API丰富（request, response）	fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
    脱离了XHR，是ES规范里新的实现方式	fetch没有办法原生监测请求的进度，而XHR可以
</code>
<code>
    axios（这是一个类库并非原生js）

    Axios 是一种基于Promise封装的HTTP客户端
    浏览器端发起XMLHttpRequests请求
    node端发起http请求
    支持Promise API
    监听请求和返回
    对请求和返回进行转化
    取消请求
    自动转换json数据
    客户端支持抵御XSRF攻击
</code>
<code>
    数组的遍历方法

    方法	改变原数组	特点
    forEach	否	无返回值
    map	否	返回新数组，可链式调用
    filter	否	过滤数组，返回包含符合条件的元素的数组，可链式调用
    for...of	否	for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环
    every	否	遍历的数组里的元素全部符合条件时，返回true
    some	否	遍历的数组里的元素至少有一个符合条件时，返回true
    find	否	返回第一个符合条件的值
    findIndex	否	返回第一个返回条件的值的索引值
    reduce	否	对数组正序操作
    reduceRight	否	对数组逆序操作
</code>
<code>
    深拷贝

    深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存），且修改新对象不会影响原来的对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂）
    实现方式如下：

    JSON.parse(JSON.stringify())
    这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了
    lodash的_.cloneDeep
    需要安装lodash
    jQuery.extend()
    手写递归循环
    递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝
    function deepClone(obj, hash = new WeakMap()) {
    if (obj === null) return obj // 如果是null或者undefined我就不进行拷贝操作
    if (obj instanceof Date) return new Date(obj)
    if (obj instanceof RegExp) return new RegExp(obj)
    // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
    if (typeof obj !== "object") return obj
    // 是对象的话就要进行深拷贝
    if (hash.get(obj)) return hash.get(obj)
    let cloneObj = new obj.constructor()
    // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
    hash.set(obj, cloneObj)
    for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
    // 实现一个递归拷贝
    cloneObj[key] = deepClone(obj[key], hash)
    }
    }
    return cloneObj
    }
</code>
<code>
    浅拷贝

    浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象
    实现方式如下：

    Object.assign()
    Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象
    let obj1 = { person: {name: "kobe", age: 41},sports:'basketball' }
    let obj2 = Object.assign({}, obj1);
    obj2.person.name = "wade";
    obj2.sports = 'football'
    console.log(obj1); // { person: { name: 'wade', age: 41 }, sports: 'basketball' }
    lodash的_.clone
    需要安装lodash
    展开运算符
    展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同
    let obj1 = { name: 'Kobe', address:{x:100,y:100}}
    let obj2= {... obj1}
    obj1.address.x = 200;
    obj1.name = 'wade'
    console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
    Array.prototype.concat()
    let arr = [1, 3, {
    username: 'kobe'
    }];
    let arr2 = arr.concat();
    arr2[2].username = 'wade';
    console.log(arr); //[ 1, 3, { username: 'wade' } ]
    Array.prototype.slice()
    let arr = [1, 3, {
    username: ' kobe'
    }];
    let arr3 = arr.slice();
    arr3[2].username = 'wade'
    console.log(arr); // [ 1, 3, { username: 'wade' } ]
</code>
<code>
    赋值与深/浅拷贝的区别

    对于引用数据类型
    赋值	深拷贝	浅拷贝
    当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。	从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。	重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。
    和原数据是否指向同一对象	第一层数据为基本数据类型且修改基本类型数据时	原数据中包含子对象且修改子对象时
    赋值	是	改变会使原数据一起改变	改变会使原数据一起改变
    深拷贝	否	改变不会使原数据一起改变	改变不会使原数据一起改变
    浅拷贝	否	改变不会使原数据一起改变	改变会使原数据一起改变
</code>
<code>
    forEach如何跳出循环

    forEach是不能通过break或者return来实现跳出循环的，forEach的回调函数形成了一个作用域，在里面使用return并不会跳出，只会被当做continue
    实现方法：try...catch

    function getItemById(arr, id) {
    var item = null;
    try {
    arr.forEach(function (curItem, i) {
    if (curItem.id == id) {
    item = curItem;
    throw Error();
    }
    })
    } catch (e) {}
    return item;
    }
</code>
<code>
    闭包

    闭包是指有权访问另一个函数作用域中的变量的函数
    闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成
    用途
    使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量
    使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收
    使用场景
    return 回一个函数
    函数作为参数
    自动执行函数
    循环赋值
    回调函数
    节流防抖
    函数柯里化
    执行过程
    形成私有上下文
    进栈执行
    开始一系列操作
    初始化作用域链（两头<当前作用域，上级作用域>）
    初始化this
    初始化arguments
    赋值形参
    变量提升
    代码执行
    正常情况下，代码执行完成之后，私有上下文出栈被回收。但是遇到特殊情况，如果当前私有上下文执行完成之后中的某个东西被执行上下文以外的东西占用，则当前私有上下文就不会出栈释放，也就是形成了不被销毁的上下文，闭包
    注意事项
    容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。
</code>
</body>
</html>
